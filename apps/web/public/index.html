<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Agent Swarm Status</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            fontFamily: {
              sans: ["Inter", "ui-sans-serif", "system-ui", "sans-serif"],
            },
          },
        },
      };
    </script>
  </head>
  <body class="min-h-screen bg-zinc-950 text-zinc-100 antialiased">
    <canvas id="bg-canvas" class="fixed inset-0 z-0 pointer-events-none opacity-30"></canvas>

    <div class="relative z-10">
      <div class="mx-auto max-w-7xl px-5 pb-16 pt-8 sm:px-8 lg:px-10">
        <header class="relative overflow-hidden rounded-2xl border border-zinc-800 bg-zinc-900 p-6 shadow-lg shadow-white/10 sm:p-8">
          <div class="relative flex flex-col gap-6 lg:flex-row lg:items-center lg:justify-between">
            <div>
              <p class="text-xs font-semibold uppercase tracking-[0.2em] text-zinc-400">AI Swarm Control Plane</p>
              <h1 class="mt-2 text-3xl font-semibold tracking-tight text-white sm:text-4xl">Queue &amp; Run Status Dashboard</h1>
              <p class="mt-3 text-sm text-zinc-400 sm:text-base">Live visibility into orchestrator queue state and runner outcomes.</p>
            </div>
            <div class="flex w-full flex-col gap-3 lg:max-w-lg lg:items-end">
              <button
                id="settings-open-button"
                type="button"
                class="inline-flex items-center gap-2 self-start rounded-lg border border-zinc-700 bg-black px-4 py-2 text-xs font-semibold uppercase tracking-[0.16em] text-zinc-200 transition hover:border-zinc-500 hover:text-white lg:self-end"
              >
                <svg class="h-4 w-4" viewBox="0 0 24 24" fill="none" aria-hidden="true">
                  <path
                    d="M9.75 4.5h4.5l.85 2.12c.3.11.6.24.88.39l2.2-.86 2.25 3.9-1.74 1.58c.03.33.03.66 0 1l1.74 1.58-2.25 3.9-2.2-.86c-.28.15-.58.28-.88.39l-.85 2.12h-4.5l-.85-2.12a7.96 7.96 0 0 1-.88-.39l-2.2.86-2.25-3.9L5.4 12.5a7.1 7.1 0 0 1 0-1L3.66 9.92l2.25-3.9 2.2.86c.28-.15.58-.28.88-.39L9.75 4.5Z"
                    stroke="currentColor"
                    stroke-width="1.5"
                    stroke-linejoin="round"
                  />
                  <circle cx="12" cy="12" r="2.6" stroke="currentColor" stroke-width="1.5" />
                </svg>
                Settings
              </button>
              <div class="grid w-full gap-3 sm:grid-cols-2">
                <div class="rounded-xl border border-zinc-800 bg-black px-4 py-3 shadow-md shadow-white/5">
                  <p class="text-[11px] font-semibold uppercase tracking-[0.18em] text-zinc-500">Target Repository</p>
                  <p id="target-repo" class="mt-1 text-sm font-semibold text-white sm:text-base">Unknown / Unknown</p>
                </div>
                <div class="rounded-xl border border-zinc-800 bg-black px-4 py-3 shadow-md shadow-white/5">
                  <p class="text-[11px] font-semibold uppercase tracking-[0.18em] text-zinc-500">Last Refresh</p>
                  <p id="last-refresh" class="mt-1 text-sm font-medium text-zinc-200 sm:text-base">Waiting for data...</p>
                </div>
              </div>
            </div>
          </div>
        </header>

        <div id="settings-modal" class="fixed inset-0 z-20 hidden">
          <div id="settings-backdrop" class="absolute inset-0 bg-black/70"></div>
          <aside
            role="dialog"
            aria-modal="true"
            aria-labelledby="settings-title"
            class="absolute right-0 top-0 h-full w-full max-w-md border-l border-zinc-800 bg-zinc-950 p-5 shadow-2xl shadow-black/80 sm:p-6"
          >
            <div class="flex items-center justify-between">
              <h2 id="settings-title" class="text-lg font-semibold tracking-tight text-white">Dashboard Settings</h2>
              <button
                id="settings-close-button"
                type="button"
                class="rounded-lg border border-zinc-700 bg-black px-3 py-1.5 text-xs font-semibold uppercase tracking-[0.12em] text-zinc-300 transition hover:border-zinc-500 hover:text-white"
              >
                Close
              </button>
            </div>
            <p class="mt-2 text-sm text-zinc-400">Update local `.agent-swarm.yml` and `.env` configuration.</p>
            <div class="mt-4 rounded-xl border border-zinc-800 bg-black/60 p-3">
              <p class="text-xs font-semibold uppercase tracking-[0.16em] text-zinc-300">Configure via GUI</p>
              <ul class="mt-2 space-y-1 text-xs text-zinc-400">
                <li><span class="font-semibold text-zinc-200">Target Owner:</span> Use the organization or username slug (e.g., `openai`).</li>
                <li><span class="font-semibold text-zinc-200">Target Repo:</span> Use the repository name slug (e.g., `whisper`).</li>
                <li><span class="font-semibold text-zinc-200">Important:</span> Do not paste full URLs into these fields.</li>
              </ul>
            </div>

            <form id="settings-form" class="mt-5 space-y-4">
              <label class="block">
                <span class="mb-1 block text-xs font-semibold uppercase tracking-[0.16em] text-zinc-400">Target Owner</span>
                <input
                  id="settings-target-owner"
                  name="targetOwner"
                  type="text"
                  required
                  autocomplete="off"
                  placeholder="openai"
                  class="w-full rounded-lg border border-zinc-700 bg-black px-3 py-2 text-sm text-white outline-none transition focus:border-zinc-500"
                />
              </label>
              <label class="block">
                <span class="mb-1 block text-xs font-semibold uppercase tracking-[0.16em] text-zinc-400">Target Repo</span>
                <input
                  id="settings-target-repo"
                  name="targetRepo"
                  type="text"
                  required
                  autocomplete="off"
                  placeholder="whisper"
                  class="w-full rounded-lg border border-zinc-700 bg-black px-3 py-2 text-sm text-white outline-none transition focus:border-zinc-500"
                />
              </label>
              <label class="block">
                <span class="mb-1 block text-xs font-semibold uppercase tracking-[0.16em] text-zinc-400">Project V2 Number</span>
                <input
                  id="settings-project-number"
                  name="projectNumber"
                  type="number"
                  required
                  min="1"
                  step="1"
                  placeholder="7"
                  class="w-full rounded-lg border border-zinc-700 bg-black px-3 py-2 text-sm text-white outline-none transition focus:border-zinc-500"
                />
              </label>
              <label class="block">
                <span class="mb-1 block text-xs font-semibold uppercase tracking-[0.16em] text-zinc-400">GitHub PAT</span>
                <input
                  id="settings-github-token"
                  name="githubToken"
                  type="password"
                  autocomplete="new-password"
                  placeholder="Enter token to set"
                  class="w-full rounded-lg border border-zinc-700 bg-black px-3 py-2 text-sm text-white outline-none transition focus:border-zinc-500"
                />
              </label>
              <div class="grid grid-cols-1 gap-4 sm:grid-cols-2">
                <label class="block">
                  <span class="mb-1 block text-xs font-semibold uppercase tracking-[0.16em] text-zinc-400">Max Executors</span>
                  <input
                    id="settings-max-executors"
                    name="maxExecutors"
                    type="number"
                    required
                    min="1"
                    step="1"
                    class="w-full rounded-lg border border-zinc-700 bg-black px-3 py-2 text-sm text-white outline-none transition focus:border-zinc-500"
                  />
                </label>
                <label class="block">
                  <span class="mb-1 block text-xs font-semibold uppercase tracking-[0.16em] text-zinc-400">Max Reviewers</span>
                  <input
                    id="settings-max-reviewers"
                    name="maxReviewers"
                    type="number"
                    required
                    min="1"
                    step="1"
                    class="w-full rounded-lg border border-zinc-700 bg-black px-3 py-2 text-sm text-white outline-none transition focus:border-zinc-500"
                  />
                </label>
              </div>
              <div
                id="settings-message"
                class="hidden rounded-lg border px-3 py-2 text-sm"
                role="status"
                aria-live="polite"
              ></div>
              <div class="flex items-center justify-end gap-3 pt-2">
                <button
                  id="settings-cancel-button"
                  type="button"
                  class="rounded-lg border border-zinc-700 bg-black px-4 py-2 text-xs font-semibold uppercase tracking-[0.12em] text-zinc-300 transition hover:border-zinc-500 hover:text-white"
                >
                  Cancel
                </button>
                <button
                  id="settings-save-button"
                  type="submit"
                  class="rounded-lg border border-zinc-200 bg-white px-4 py-2 text-xs font-semibold uppercase tracking-[0.12em] text-zinc-950 transition hover:bg-zinc-200 disabled:cursor-not-allowed disabled:opacity-60"
                >
                  Save Settings
                </button>
              </div>
            </form>
          </aside>
        </div>

        <div id="error-banner" class="mt-5 hidden rounded-xl border border-zinc-700 bg-zinc-900 px-4 py-3 text-sm font-medium text-zinc-200 shadow-md shadow-white/5"></div>

        <section class="mt-7 rounded-2xl border border-zinc-800 bg-zinc-900 p-5 shadow-lg shadow-white/10 sm:p-6">
          <div class="flex flex-wrap items-center justify-between gap-4">
            <div>
              <h2 class="text-xl font-semibold tracking-tight text-white">Initialize Sprint</h2>
              <p class="mt-1 text-sm text-zinc-400">
                Step 1 saves your high-level sprint goal to local kickoff state. Step 2 starts kickoff loop execution. If tasks already exist, you can start the runner loop directly without kickoff.
              </p>
            </div>
          </div>

          <form id="kickoff-form" class="mt-5">
            <label for="kickoff-goal" class="mb-2 block text-xs font-semibold uppercase tracking-[0.16em] text-zinc-400">
              Sprint Goal
            </label>
            <textarea
              id="kickoff-goal"
              name="goal"
              rows="7"
              placeholder="Example: Ship sprint kickoff validation hardening and add tests for claim lease expiration handling."
              class="w-full rounded-xl border border-zinc-700 bg-black px-4 py-3 text-sm text-zinc-100 outline-none transition focus:border-zinc-500"
            ></textarea>
            <div class="mt-3 rounded-lg border border-zinc-800 bg-black px-3 py-2 text-xs text-zinc-400">
              <p class="font-semibold uppercase tracking-[0.16em] text-zinc-300">Start Workflow</p>
              <p class="mt-1">
                Click <span class="font-semibold text-zinc-200">Start Kickoff Loop (Step 2)</span> to launch kickoff from the GUI. Manual fallback:
                `python3 -m apps.runner --kickoff --sprint M1 --goal-file ./goal.txt --loop`
              </p>
              <p class="mt-1">
                Resume existing tasks without kickoff: click <span class="font-semibold text-zinc-200">Start Runner Loop (No Kickoff)</span> or run
                `python3 -m apps.runner --sprint M1 --loop`
              </p>
            </div>
            <div class="mt-4 flex flex-wrap items-end gap-3">
              <label class="block min-w-[110px]">
                <span class="mb-1 block text-xs font-semibold uppercase tracking-[0.16em] text-zinc-400">Sprint</span>
                <input
                  id="kickoff-sprint"
                  name="sprint"
                  type="text"
                  value="M1"
                  placeholder="M1"
                  autocomplete="off"
                  class="w-full rounded-lg border border-zinc-700 bg-black px-3 py-2 text-sm text-white outline-none transition focus:border-zinc-500"
                />
              </label>
              <button
                id="kickoff-submit-button"
                type="submit"
                class="inline-flex items-center gap-2 rounded-lg border border-zinc-200 bg-white px-4 py-2 text-xs font-semibold uppercase tracking-[0.12em] text-zinc-950 transition hover:bg-zinc-200 disabled:cursor-not-allowed disabled:opacity-60"
              >
                <span
                  id="kickoff-button-spinner"
                  class="hidden h-3 w-3 animate-spin rounded-full border-2 border-zinc-900 border-r-transparent"
                  aria-hidden="true"
                ></span>
                <span id="kickoff-button-label">Save Goal (Step 1)</span>
              </button>
              <button
                id="kickoff-start-loop-button"
                type="button"
                class="inline-flex items-center gap-2 rounded-lg border border-zinc-700 bg-black px-4 py-2 text-xs font-semibold uppercase tracking-[0.12em] text-zinc-200 transition hover:border-zinc-500 hover:text-white disabled:cursor-not-allowed disabled:opacity-60"
              >
                <span
                  id="kickoff-start-loop-spinner"
                  class="hidden h-3 w-3 animate-spin rounded-full border-2 border-zinc-200 border-r-transparent"
                  aria-hidden="true"
                ></span>
                <span id="kickoff-start-loop-label">Start Kickoff Loop (Step 2)</span>
              </button>
              <button
                id="kickoff-start-runner-loop-button"
                type="button"
                class="inline-flex items-center gap-2 rounded-lg border border-zinc-700 bg-black px-4 py-2 text-xs font-semibold uppercase tracking-[0.12em] text-zinc-200 transition hover:border-zinc-500 hover:text-white disabled:cursor-not-allowed disabled:opacity-60"
              >
                <span
                  id="kickoff-start-runner-loop-spinner"
                  class="hidden h-3 w-3 animate-spin rounded-full border-2 border-zinc-200 border-r-transparent"
                  aria-hidden="true"
                ></span>
                <span id="kickoff-start-runner-loop-label">Start Runner Loop (No Kickoff)</span>
              </button>
            </div>
            <p
              id="kickoff-message"
              class="hidden mt-3 w-full rounded-lg border px-3 py-2 text-sm"
              role="status"
              aria-live="polite"
            ></p>
          </form>
        </section>

        <main class="mt-7 grid gap-6 xl:grid-cols-5">
          <section class="xl:col-span-3 rounded-2xl border border-zinc-800 bg-zinc-900 p-5 shadow-lg shadow-white/10 sm:p-6">
            <div class="flex flex-wrap items-center justify-between gap-4">
              <div>
                <h2 class="text-xl font-semibold tracking-tight text-white">Orchestrator State</h2>
                <p class="mt-1 text-sm text-zinc-400">Current sprint queue with status and dispatch context.</p>
              </div>
              <div class="rounded-full border border-zinc-700 bg-black px-4 py-2 text-sm font-medium text-zinc-300">
                Sprint: <span id="orchestrator-sprint" class="font-semibold text-white">N/A</span>
              </div>
            </div>

            <div id="orchestrator-summary" class="mt-5 flex flex-wrap gap-2"></div>
            <div id="orchestrator-items" class="mt-5 space-y-3"></div>
          </section>

          <section class="xl:col-span-2 rounded-2xl border border-zinc-800 bg-zinc-900 p-5 shadow-lg shadow-white/10 sm:p-6">
            <div class="flex flex-wrap items-center justify-between gap-4">
              <div>
                <h2 class="text-xl font-semibold tracking-tight text-white">Runner Ledger</h2>
                <p class="mt-1 text-sm text-zinc-400">Recent executor/reviewer runs and outcomes.</p>
              </div>
              <div
                id="runner-count"
                class="rounded-full border border-zinc-700 bg-black px-3 py-1 text-xs font-semibold uppercase tracking-[0.16em] text-zinc-300"
              >
                0 Runs
              </div>
            </div>

            <div id="runner-runs" class="mt-5 space-y-4"></div>
          </section>
        </main>

        <section class="mt-7 rounded-2xl border border-zinc-800 bg-zinc-900 p-5 shadow-lg shadow-white/10 sm:p-6">
          <div>
            <h2 class="text-xl font-semibold tracking-tight text-white">Live Agent Terminals</h2>
            <p class="mt-1 text-sm text-zinc-400">Real-time transcript stream for active and recently completed runs.</p>
          </div>
          <div
            id="terminal-health-banner"
            class="mt-4 hidden rounded-xl border border-zinc-600 bg-zinc-950/90 px-4 py-3 text-xs text-zinc-200"
          ></div>
          <div class="mt-5">
            <ul id="terminal-tabs" class="flex overflow-x-auto border-b border-zinc-800"></ul>
            <div
              id="terminal-window"
              class="bg-black text-zinc-300 font-mono text-[10px] sm:text-xs p-4 h-96 overflow-y-auto rounded-b-xl border border-zinc-800 shadow-inner"
            >
              <pre id="terminal-output" class="whitespace-pre text-zinc-300">Waiting for an active run...</pre>
            </div>
          </div>
        </section>
      </div>
    </div>

    <script>
      const POLL_INTERVAL_MS = 15000;
      const TERMINAL_STREAM_RECONNECT_MS = 1500;
      const TERMINAL_RECENT_WINDOW_MS = 20 * 60 * 1000;
      const orchestratorItemsEl = document.getElementById("orchestrator-items");
      const orchestratorSummaryEl = document.getElementById("orchestrator-summary");
      const orchestratorSprintEl = document.getElementById("orchestrator-sprint");
      const runnerRunsEl = document.getElementById("runner-runs");
      const runnerCountEl = document.getElementById("runner-count");
      const terminalTabsEl = document.getElementById("terminal-tabs");
      const terminalWindowEl = document.getElementById("terminal-window");
      const terminalOutputEl = document.getElementById("terminal-output");
      const terminalHealthBannerEl = document.getElementById("terminal-health-banner");
      const targetRepoEl = document.getElementById("target-repo");
      const lastRefreshEl = document.getElementById("last-refresh");
      const errorBannerEl = document.getElementById("error-banner");
      const settingsOpenButtonEl = document.getElementById("settings-open-button");
      const settingsModalEl = document.getElementById("settings-modal");
      const settingsBackdropEl = document.getElementById("settings-backdrop");
      const settingsCloseButtonEl = document.getElementById("settings-close-button");
      const settingsCancelButtonEl = document.getElementById("settings-cancel-button");
      const settingsFormEl = document.getElementById("settings-form");
      const settingsSaveButtonEl = document.getElementById("settings-save-button");
      const settingsMessageEl = document.getElementById("settings-message");
      const settingsTargetOwnerEl = document.getElementById("settings-target-owner");
      const settingsTargetRepoEl = document.getElementById("settings-target-repo");
      const settingsProjectNumberEl = document.getElementById("settings-project-number");
      const settingsGithubTokenEl = document.getElementById("settings-github-token");
      const settingsMaxExecutorsEl = document.getElementById("settings-max-executors");
      const settingsMaxReviewersEl = document.getElementById("settings-max-reviewers");
      const kickoffFormEl = document.getElementById("kickoff-form");
      const kickoffGoalEl = document.getElementById("kickoff-goal");
      const kickoffSprintEl = document.getElementById("kickoff-sprint");
      const kickoffMessageEl = document.getElementById("kickoff-message");
      const kickoffSubmitButtonEl = document.getElementById("kickoff-submit-button");
      const kickoffButtonSpinnerEl = document.getElementById("kickoff-button-spinner");
      const kickoffButtonLabelEl = document.getElementById("kickoff-button-label");
      const kickoffStartLoopButtonEl = document.getElementById("kickoff-start-loop-button");
      const kickoffStartLoopSpinnerEl = document.getElementById("kickoff-start-loop-spinner");
      const kickoffStartLoopLabelEl = document.getElementById("kickoff-start-loop-label");
      const kickoffStartRunnerLoopButtonEl = document.getElementById("kickoff-start-runner-loop-button");
      const kickoffStartRunnerLoopSpinnerEl = document.getElementById("kickoff-start-runner-loop-spinner");
      const kickoffStartRunnerLoopLabelEl = document.getElementById("kickoff-start-runner-loop-label");

      const canvas = document.getElementById("bg-canvas");
      const ctx = canvas.getContext("2d");
      const nodes = [];
      let canvasWidth = 0;
      let canvasHeight = 0;
      let animationFrameId = 0;
      let activityTarget = 0.12;
      let activityCurrent = 0.12;
      let lastFrameTime = performance.now();
      let isSettingsOpen = false;
      let activeTerminalRunId = "";
      let terminalRunIds = [];
      const terminalLogCache = new Map();
      const terminalLogSeqByRun = new Map();
      const terminalRunMetaById = new Map();
      let terminalStreamSource = null;
      let terminalStreamRunId = "";
      let terminalStreamReconnectTimerId = 0;
      let terminalStreamSessionId = 0;
      const settingsFieldByName = {
        targetOwner: settingsTargetOwnerEl,
        targetRepo: settingsTargetRepoEl,
        projectNumber: settingsProjectNumberEl,
        githubToken: settingsGithubTokenEl,
        maxExecutors: settingsMaxExecutorsEl,
        maxReviewers: settingsMaxReviewersEl,
      };

      function asObject(value) {
        return value && typeof value === "object" && !Array.isArray(value) ? value : {};
      }

      function escapeHtml(value) {
        return String(value ?? "")
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll('"', "&quot;")
          .replaceAll("'", "&#39;");
      }

      function formatTime(value) {
        const parsed = new Date(value ?? "");
        if (Number.isNaN(parsed.getTime())) {
          return "Unknown time";
        }
        return parsed.toLocaleString();
      }

      function normalizeSprint(value) {
        const normalized = String(value ?? "").trim().toUpperCase();
        return /^M[1-4]$/u.test(normalized) ? normalized : null;
      }

      function statusBadgeClasses(status) {
        const normalized = String(status ?? "").trim();
        if (normalized === "Done") return "bg-white text-black border border-white/80";
        if (normalized === "In Progress") return "bg-zinc-200 text-zinc-950 border border-zinc-300";
        if (normalized === "In Review") return "bg-zinc-300 text-zinc-950 border border-zinc-300";
        if (normalized === "Ready") return "bg-zinc-100 text-zinc-950 border border-zinc-200";
        if (normalized === "Blocked") return "bg-zinc-800 text-zinc-100 border border-zinc-600";
        if (normalized === "Needs Human Approval") return "bg-zinc-700 text-zinc-100 border border-zinc-500";
        if (normalized === "Backlog") return "bg-zinc-900 text-zinc-300 border border-zinc-700";
        return "bg-zinc-900 text-zinc-300 border border-zinc-700";
      }

      function runBadgeClasses(status) {
        const normalized = String(status ?? "").toLowerCase();
        if (normalized === "succeeded") return "bg-white text-black border border-white/80";
        if (normalized === "running") return "bg-zinc-200 text-zinc-950 border border-zinc-300";
        if (normalized === "queued") return "bg-zinc-300 text-zinc-950 border border-zinc-300";
        if (normalized === "failed") return "bg-zinc-800 text-zinc-100 border border-zinc-600";
        if (normalized === "skipped") return "bg-zinc-900 text-zinc-300 border border-zinc-700";
        return "bg-zinc-900 text-zinc-300 border border-zinc-700";
      }

      function deriveTargetFromData(orchestrator, runner, ownerHeader, repoHeader) {
        if (ownerHeader && repoHeader) {
          return `${ownerHeader}/${repoHeader}`;
        }

        const runnerEntries = Object.values(asObject(runner));
        for (const entry of runnerEntries) {
          const prUrl =
            entry?.result?.pr_url ??
            entry?.result?.urls?.pr_url ??
            entry?.result?.urls?.pull_request ??
            entry?.result?.pull_request_url;
          if (typeof prUrl !== "string") {
            continue;
          }
          const match = prUrl.match(/github\.com\/([^/]+)\/([^/]+)/i);
          if (match?.[1] && match?.[2]) {
            return `${match[1]}/${match[2]}`;
          }
        }

        const sprintPlanTarget = orchestrator?.sprint_plan?.target;
        if (typeof sprintPlanTarget === "string" && sprintPlanTarget.includes("/")) {
          return sprintPlanTarget;
        }

        return "Unknown / Unknown";
      }

      function deriveSprint(orchestrator) {
        const sprintFromPlan = orchestrator?.sprint_plan?.sprint;
        if (typeof sprintFromPlan === "string" && sprintFromPlan.trim()) {
          return sprintFromPlan.trim();
        }

        const items = Object.values(asObject(orchestrator?.items));
        for (const item of items) {
          const sprint = item?.last_seen_sprint;
          if (typeof sprint === "string" && sprint.trim()) {
            return sprint.trim();
          }
        }

        return "N/A";
      }

      function computeAnimationActivity(orchestrator, runner) {
        const items = Object.values(asObject(orchestrator?.items));
        const activeItemStatuses = new Set([
          "Ready",
          "In Progress",
          "In Review",
          "Needs Human Approval",
          "Blocked",
        ]);

        const hasActiveQueueItems = items.some((item) => activeItemStatuses.has(String(item?.last_seen_status ?? "")));

        const runs = Object.values(asObject(runner));
        const hasRunningRun = runs.some((run) => String(run?.status ?? "").toLowerCase() === "running");

        activityTarget = hasActiveQueueItems || hasRunningRun ? 1 : 0.12;
      }

      function renderOrchestrator(orchestrator) {
        const itemsObj = asObject(orchestrator?.items);
        const entries = Object.entries(itemsObj)
          .map(([projectItemId, value]) => ({
            projectItemId,
            issueNumber: Number(value?.last_seen_issue_number ?? 0),
            issueTitle: typeof value?.last_seen_issue_title === "string" ? value.last_seen_issue_title.trim() : "",
            status: String(value?.last_seen_status ?? "Unknown"),
            lastSeenAt: value?.last_seen_at ?? "",
            statusSinceAt: value?.status_since_at ?? "",
            lastRole: value?.last_dispatched_role ?? "",
            lastRunId: value?.last_run_id ?? "",
            reviewCycles: Number(value?.review_cycle_count ?? 0),
          }))
          .sort((left, right) => {
            if (left.issueNumber && right.issueNumber && left.issueNumber !== right.issueNumber) {
              return left.issueNumber - right.issueNumber;
            }
            return String(left.projectItemId).localeCompare(String(right.projectItemId));
          });

        const statusCounts = {};
        for (const entry of entries) {
          statusCounts[entry.status] = (statusCounts[entry.status] ?? 0) + 1;
        }

        orchestratorSummaryEl.innerHTML = "";
        const statusPairs = Object.entries(statusCounts);
        if (statusPairs.length > 0) {
          orchestratorSummaryEl.innerHTML = statusPairs
            .map(
              ([status, count]) =>
                `<span class="inline-flex items-center gap-2 rounded-full px-3 py-1 text-xs font-semibold ${statusBadgeClasses(status)}">${escapeHtml(status)} <span class="text-[11px] opacity-80">${count}</span></span>`,
            )
            .join("");
        }

        if (entries.length === 0) {
          orchestratorItemsEl.innerHTML = `
            <div class="rounded-2xl border border-dashed border-zinc-700 bg-black px-6 py-10 text-center">
              <p class="text-sm font-semibold text-zinc-200">No queue activity yet</p>
              <p class="mt-2 text-sm text-zinc-500">When orchestrator state appears, sprint items will show up here with live status badges.</p>
            </div>
          `;
          return;
        }

        orchestratorItemsEl.innerHTML = entries
          .map(
            (entry) => `
              <article class="rounded-xl border border-zinc-800 bg-black p-4 shadow-md shadow-white/5 transition hover:-translate-y-0.5 hover:shadow-lg hover:shadow-white/10">
                <div class="flex flex-wrap items-start justify-between gap-3">
                  <div>
                    <p class="text-xs font-medium uppercase tracking-[0.16em] text-zinc-500">Issue</p>
                    <h3 class="mt-1 text-base font-semibold text-white">${
                      entry.issueNumber > 0 ? `#${entry.issueNumber}` : "Unnumbered Issue"
                    }${
                      entry.issueTitle ? ` · ${escapeHtml(entry.issueTitle)}` : ""
                    }</h3>
                  </div>
                  <span class="inline-flex rounded-full px-3 py-1 text-xs font-semibold ${statusBadgeClasses(entry.status)}">${escapeHtml(entry.status)}</span>
                </div>
                <div class="mt-3 grid gap-2 text-xs text-zinc-400 sm:grid-cols-2">
                  <p>Last seen: <span class="font-medium text-zinc-200">${escapeHtml(formatTime(entry.lastSeenAt))}</span></p>
                  <p>In status since: <span class="font-medium text-zinc-200">${escapeHtml(formatTime(entry.statusSinceAt))}</span></p>
                  <p>Last dispatch role: <span class="font-medium text-zinc-200">${escapeHtml(entry.lastRole || "—")}</span></p>
                  <p>Review cycles: <span class="font-medium text-zinc-200">${Number.isFinite(entry.reviewCycles) ? entry.reviewCycles : 0}</span></p>
                </div>
                ${
                  entry.lastRunId
                    ? `<p class="mt-3 rounded-lg border border-zinc-800 bg-zinc-900/70 px-3 py-2 text-[11px] text-zinc-500">run_id: <span class="font-mono text-[11px] text-zinc-300">${escapeHtml(entry.lastRunId)}</span></p>`
                    : ""
                }
              </article>
            `,
          )
          .join("");
      }

      function toTimestampMs(value) {
        const parsed = new Date(value ?? "").getTime();
        if (Number.isNaN(parsed)) {
          return 0;
        }
        return parsed;
      }

      function buildRunnerEntries(runner) {
        return Object.values(asObject(runner))
          .filter((value) => value && typeof value === "object")
          .map((value) => {
            const timestamp =
              value?.running_at ??
              value?.result?.completed_at ??
              value?.result?.finished_at ??
              value?.result?.updated_at ??
              value?.received_at;

            const blockedReason =
              value?.result?.blocked_reason ??
              value?.result?.reason ??
              value?.result?.error ??
              value?.result?.message ??
              "";
            const summary = typeof value?.result?.summary === "string" ? value.result.summary : "";
            const errorMessages = Array.isArray(value?.result?.errors)
              ? value.result.errors
                  .map((errorEntry) => {
                    if (errorEntry && typeof errorEntry === "object") {
                      const message = errorEntry.message ?? errorEntry.error ?? errorEntry.code;
                      return typeof message === "string" ? message.trim() : "";
                    }
                    return typeof errorEntry === "string" ? errorEntry.trim() : "";
                  })
                  .filter((message) => message.length > 0)
              : [];

            const timestampMs = toTimestampMs(timestamp);
            return {
              runId: value?.run_id ?? "",
              role: value?.role ?? "UNKNOWN",
              status: value?.status ?? "unknown",
              timestamp,
              timestampMs,
              receivedAt: value?.received_at ?? "",
              outcome: value?.result?.outcome ?? "",
              summary,
              errorMessages,
              blockedReason: typeof blockedReason === "string" ? blockedReason : "",
              prUrl:
                value?.result?.pr_url ??
                value?.result?.urls?.pr_url ??
                value?.result?.urls?.pull_request ??
                "",
            };
          })
          .sort((left, right) => right.timestampMs - left.timestampMs)
          .slice(0, 30);
      }

      function collectTerminalRunIds(runnerEntries) {
        const nowMs = Date.now();
        const runIds = [];
        const seen = new Set();
        for (const entry of runnerEntries) {
          const runId = String(entry?.runId ?? "").trim();
          if (!runId || seen.has(runId)) {
            continue;
          }

          const normalizedStatus = String(entry?.status ?? "").toUpperCase();
          const isRunning = normalizedStatus === "RUNNING";
          const isFinished = normalizedStatus === "SUCCEEDED" || normalizedStatus === "FAILED" || normalizedStatus === "SKIPPED";
          const isRecentlyFinished = isFinished && entry.timestampMs > 0 && nowMs - entry.timestampMs <= TERMINAL_RECENT_WINDOW_MS;

          if (!isRunning && !isRecentlyFinished) {
            continue;
          }

          seen.add(runId);
          runIds.push(runId);
        }
        return runIds;
      }

      function normalizeRoleLabel(value) {
        const normalized = String(value ?? "").trim().toUpperCase();
        if (normalized) {
          return normalized;
        }
        return "AGENT";
      }

      function shortRunSuffix(runId) {
        const normalized = String(runId ?? "").replaceAll(/[^A-Za-z0-9]/g, "").toLowerCase();
        if (!normalized) {
          return "0000";
        }
        return normalized.slice(0, 4);
      }

      function isScrolledToBottom(element) {
        if (!element) {
          return true;
        }
        return element.scrollTop + element.clientHeight >= element.scrollHeight - 8;
      }

      function renderTerminalOutput(logs) {
        const shouldStickToBottom = isScrolledToBottom(terminalWindowEl);
        const content = typeof logs === "string" && logs.length > 0 ? logs : "No logs available for this run yet.";
        terminalOutputEl.textContent = content;
        if (shouldStickToBottom) {
          terminalWindowEl.scrollTop = terminalWindowEl.scrollHeight;
        }
      }

      function renderTerminalTabs() {
        if (terminalRunIds.length === 0) {
          terminalTabsEl.innerHTML = `
            <li class="px-3 py-2 text-[11px] font-semibold uppercase tracking-[0.16em] text-zinc-500">No active runs</li>
          `;
          terminalOutputEl.textContent = "Waiting for an active or recently finished run...";
          return;
        }

        const roleCounts = {};
        for (const runId of terminalRunIds) {
          const role = normalizeRoleLabel(terminalRunMetaById.get(runId)?.role);
          roleCounts[role] = (roleCounts[role] ?? 0) + 1;
        }

        terminalTabsEl.innerHTML = terminalRunIds
          .map((runId) => {
            const isActive = runId === activeTerminalRunId;
            const role = normalizeRoleLabel(terminalRunMetaById.get(runId)?.role);
            const label = roleCounts[role] > 1 ? `${role} (${shortRunSuffix(runId)})` : role;
            return `
              <li>
                <button
                  type="button"
                  data-run-id="${escapeHtml(runId)}"
                  class="border-r border-zinc-800 px-3 py-2 text-[11px] font-semibold uppercase tracking-[0.14em] transition ${
                    isActive ? "bg-zinc-800 text-white" : "bg-transparent text-zinc-400 hover:bg-zinc-900 hover:text-zinc-200"
                  }"
                >
                  ${escapeHtml(label)}
                </button>
              </li>
            `;
          })
          .join("");

        const cachedLogs = terminalLogCache.get(activeTerminalRunId);
        if (typeof cachedLogs === "string") {
          renderTerminalOutput(cachedLogs);
          return;
        }
        terminalOutputEl.textContent = "Loading logs...";
      }

      function setActiveTerminalRun(runId) {
        const normalizedRunId = String(runId ?? "").trim();
        if (!normalizedRunId || !terminalRunIds.includes(normalizedRunId)) {
          return;
        }
        if (normalizedRunId === activeTerminalRunId) {
          return;
        }
        activeTerminalRunId = normalizedRunId;
        renderTerminalTabs();
        restartTerminalStreamNow();
      }

      function syncTerminalRuns(runnerEntries) {
        const previousRunKey = terminalRunIds.join("|");
        const previousActiveRunId = activeTerminalRunId;
        terminalRunIds = collectTerminalRunIds(runnerEntries);
        terminalRunMetaById.clear();
        for (const entry of runnerEntries) {
          const runId = String(entry?.runId ?? "").trim();
          if (!runId || !terminalRunIds.includes(runId)) {
            continue;
          }
          if (!terminalRunMetaById.has(runId)) {
            terminalRunMetaById.set(runId, entry);
          }
        }
        if (terminalRunIds.length === 0) {
          activeTerminalRunId = "";
          terminalLogCache.clear();
          terminalLogSeqByRun.clear();
          closeTerminalStream();
          clearTerminalStreamReconnectTimer();
          renderTerminalTabs();
          return;
        }

        for (const runId of Array.from(terminalLogCache.keys())) {
          if (!terminalRunIds.includes(runId) && runId !== activeTerminalRunId) {
            terminalLogCache.delete(runId);
          }
        }
        for (const runId of Array.from(terminalLogSeqByRun.keys())) {
          if (!terminalRunIds.includes(runId) && runId !== activeTerminalRunId) {
            terminalLogSeqByRun.delete(runId);
          }
        }

        if (!terminalRunIds.includes(activeTerminalRunId)) {
          activeTerminalRunId = terminalRunIds[0];
        }

        renderTerminalTabs();
        const nextRunKey = terminalRunIds.join("|");
        const runSetChanged = previousRunKey !== nextRunKey;
        const activeChanged = previousActiveRunId !== activeTerminalRunId;
        const streamMismatched = terminalStreamRunId !== activeTerminalRunId;
        if (runSetChanged || activeChanged || streamMismatched || !terminalStreamSource) {
          restartTerminalStreamNow();
        }
      }

      function clearTerminalStreamReconnectTimer() {
        if (terminalStreamReconnectTimerId) {
          window.clearTimeout(terminalStreamReconnectTimerId);
          terminalStreamReconnectTimerId = 0;
        }
      }

      function closeTerminalStream() {
        if (terminalStreamSource) {
          terminalStreamSource.close();
          terminalStreamSource = null;
        }
        terminalStreamRunId = "";
      }

      async function loadTerminalSnapshot(runId, sessionId) {
        const response = await fetch(`/internal/logs/${encodeURIComponent(runId)}`, { cache: "no-store" });
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }
        const payload = asObject(await response.json());
        const logs = typeof payload.logs === "string" ? payload.logs : "";
        const seq = Number.isInteger(payload.seq) && payload.seq > 0 ? payload.seq : 0;
        terminalLogCache.set(runId, logs);
        terminalLogSeqByRun.set(runId, seq);
        if (sessionId === terminalStreamSessionId && runId === activeTerminalRunId) {
          renderTerminalOutput(logs);
        }
      }

      function scheduleTerminalStreamReconnect(sessionId, delayMs = TERMINAL_STREAM_RECONNECT_MS) {
        clearTerminalStreamReconnectTimer();
        terminalStreamReconnectTimerId = window.setTimeout(() => {
          if (sessionId !== terminalStreamSessionId) {
            return;
          }
          void startTerminalStreamSession(sessionId);
        }, Math.max(250, Number(delayMs) || 0));
      }

      function connectTerminalStream(runId, sessionId) {
        if (document.hidden || !runId || runId !== activeTerminalRunId || sessionId !== terminalStreamSessionId) {
          return;
        }

        const after = terminalLogSeqByRun.get(runId) ?? 0;
        const source = new EventSource(`/internal/logs/stream/${encodeURIComponent(runId)}?after=${encodeURIComponent(after)}`);
        terminalStreamSource = source;
        terminalStreamRunId = runId;

        source.addEventListener("transcript", (event) => {
          if (sessionId !== terminalStreamSessionId || runId !== activeTerminalRunId) {
            return;
          }
          let payload = {};
          try {
            payload = asObject(JSON.parse(event.data || "{}"));
          } catch {
            payload = {};
          }
          const chunk = typeof payload.chunk === "string" ? payload.chunk : "";
          if (!chunk) {
            return;
          }
          const seq = Number.isInteger(payload.seq) && payload.seq > 0 ? payload.seq : 0;
          const currentSeq = terminalLogSeqByRun.get(runId) ?? 0;
          if (seq > 0 && seq <= currentSeq) {
            return;
          }
          const previous = terminalLogCache.get(runId) ?? "";
          const nextLogs = `${previous}${chunk}`;
          terminalLogCache.set(runId, nextLogs);
          if (seq > 0) {
            terminalLogSeqByRun.set(runId, seq);
          }
          renderTerminalOutput(nextLogs);
        });

        source.addEventListener("ping", () => {});

        source.onerror = () => {
          if (sessionId !== terminalStreamSessionId || source !== terminalStreamSource || runId !== activeTerminalRunId) {
            return;
          }
          closeTerminalStream();
          scheduleTerminalStreamReconnect(sessionId);
        };
      }

      async function startTerminalStreamSession(sessionId) {
        const runId = activeTerminalRunId;
        if (!runId || document.hidden || sessionId !== terminalStreamSessionId) {
          return;
        }
        try {
          await loadTerminalSnapshot(runId, sessionId);
        } catch (error) {
          if (sessionId !== terminalStreamSessionId || runId !== activeTerminalRunId) {
            return;
          }
          if (!terminalLogCache.has(runId)) {
            terminalOutputEl.textContent = `Unable to load logs for ${runId}: ${error?.message ?? "Unknown error"}`;
          }
          scheduleTerminalStreamReconnect(sessionId);
          return;
        }
        if (sessionId !== terminalStreamSessionId || runId !== activeTerminalRunId || document.hidden) {
          return;
        }
        connectTerminalStream(runId, sessionId);
      }

      function restartTerminalStreamNow() {
        terminalStreamSessionId += 1;
        const sessionId = terminalStreamSessionId;
        closeTerminalStream();
        clearTerminalStreamReconnectTimer();
        if (!activeTerminalRunId || document.hidden) {
          return;
        }
        void startTerminalStreamSession(sessionId);
      }

      function deriveRunFailureDetail(entry) {
        const parts = [];
        const summary = typeof entry?.summary === "string" ? entry.summary.trim() : "";
        if (summary.length > 0) {
          parts.push(summary);
        }

        const errorMessages = Array.isArray(entry?.errorMessages) ? entry.errorMessages : [];
        for (const message of errorMessages.slice(0, 3)) {
          if (typeof message !== "string") {
            continue;
          }
          const normalized = message.trim();
          if (!normalized || parts.includes(normalized)) {
            continue;
          }
          parts.push(normalized);
        }

        const blockedReason = typeof entry?.blockedReason === "string" ? entry.blockedReason.trim() : "";
        if (blockedReason && !parts.includes(blockedReason)) {
          parts.push(blockedReason);
        }

        if (parts.length === 0) {
          return "";
        }
        return parts.join(" | ");
      }

      function setTerminalHealthBanner(message) {
        const normalized = String(message ?? "").trim();
        if (!normalized) {
          terminalHealthBannerEl.textContent = "";
          terminalHealthBannerEl.classList.add("hidden");
          return;
        }
        terminalHealthBannerEl.textContent = normalized;
        terminalHealthBannerEl.classList.remove("hidden");
      }

      function renderTerminalHealth(entries) {
        const latestOrchestrator = entries.find((entry) => String(entry?.role ?? "").toUpperCase() === "ORCHESTRATOR");
        const orchestratorRunning = entries.some(
          (entry) =>
            String(entry?.role ?? "").toUpperCase() === "ORCHESTRATOR" &&
            String(entry?.status ?? "").toUpperCase() === "RUNNING",
        );

        if (orchestratorRunning || !latestOrchestrator) {
          setTerminalHealthBanner("");
          return;
        }

        const latestStatus = String(latestOrchestrator?.status ?? "").toUpperCase();
        if (latestStatus !== "FAILED") {
          setTerminalHealthBanner("");
          return;
        }

        const detail = deriveRunFailureDetail(latestOrchestrator) || "No detailed error message was captured.";
        const atTime = formatTime(latestOrchestrator.timestamp || latestOrchestrator.receivedAt);
        setTerminalHealthBanner(
          `Orchestrator loop is not running. Last run failed at ${atTime}. ${detail} Restart Runner Loop after resolving this error.`,
        );
      }

      function renderRunner(entries) {
        runnerCountEl.textContent = `${entries.length} Run${entries.length === 1 ? "" : "s"}`;

        if (entries.length === 0) {
          runnerRunsEl.innerHTML = `
            <div class="rounded-2xl border border-dashed border-zinc-700 bg-black px-5 py-10 text-center">
              <p class="text-sm font-semibold text-zinc-200">No runner entries yet</p>
              <p class="mt-2 text-sm text-zinc-500">As runs are queued and executed, this timeline will populate automatically.</p>
            </div>
          `;
          return;
        }

        runnerRunsEl.innerHTML = entries
          .map((entry) => {
            const normalizedStatus = String(entry.status ?? "").toLowerCase();
            const showBlocked = normalizedStatus === "failed" || normalizedStatus === "blocked";
            const failureDetail = deriveRunFailureDetail(entry);
            return `
              <article class="relative rounded-xl border border-zinc-800 bg-black p-4 shadow-md shadow-white/5">
                <div class="absolute left-0 top-5 h-4 w-1 rounded-r-full ${showBlocked ? "bg-zinc-500" : "bg-white/70"}"></div>
                <div class="flex flex-wrap items-start justify-between gap-3 pl-3">
                  <div>
                    <p class="text-xs font-semibold uppercase tracking-[0.16em] text-zinc-500">${escapeHtml(entry.role)}</p>
                    <p class="mt-1 text-sm font-semibold text-white">${entry.runId ? escapeHtml(entry.runId) : "Unknown run"}</p>
                    <p class="mt-1 text-xs text-zinc-500">${escapeHtml(formatTime(entry.timestamp || entry.receivedAt))}</p>
                  </div>
                  <span class="inline-flex rounded-full px-3 py-1 text-xs font-semibold ${runBadgeClasses(entry.status)}">${escapeHtml(String(entry.status).toUpperCase())}</span>
                </div>
                ${
                  entry.outcome
                    ? `<p class="mt-3 pl-3 text-xs text-zinc-400">Outcome: <span class="font-semibold text-zinc-200">${escapeHtml(entry.outcome)}</span></p>`
                    : ""
                }
                ${
                  showBlocked && failureDetail
                    ? `<p class="mt-3 rounded-lg border border-zinc-700 bg-zinc-900/80 px-3 py-2 text-xs text-zinc-300">${escapeHtml(failureDetail)}</p>`
                    : ""
                }
                ${
                  entry.prUrl
                    ? `<a class="mt-3 inline-flex pl-3 text-xs font-semibold text-zinc-200 underline decoration-zinc-600 underline-offset-4 hover:text-white" target="_blank" rel="noreferrer" href="${escapeHtml(entry.prUrl)}">Open linked PR</a>`
                    : ""
                }
              </article>
            `;
          })
          .join("");
      }

      function showError(message) {
        errorBannerEl.textContent = message;
        errorBannerEl.classList.remove("hidden");
      }

      function clearError() {
        errorBannerEl.textContent = "";
        errorBannerEl.classList.add("hidden");
      }

      function setSettingsOpen(nextOpen) {
        isSettingsOpen = Boolean(nextOpen);
        settingsModalEl.classList.toggle("hidden", !isSettingsOpen);
        document.body.classList.toggle("overflow-hidden", isSettingsOpen);

        if (isSettingsOpen) {
          settingsTargetOwnerEl.focus();
        }
      }

      function showSettingsMessage(message, type = "info") {
        settingsMessageEl.textContent = message;
        settingsMessageEl.classList.remove("hidden", "border-zinc-700", "text-zinc-200", "border-zinc-500", "text-white");
        if (type === "error") {
          settingsMessageEl.classList.add("border-zinc-700", "bg-zinc-900", "text-zinc-200");
          return;
        }
        settingsMessageEl.classList.add("border-zinc-500", "bg-zinc-900", "text-white");
      }

      function clearSettingsMessage() {
        settingsMessageEl.textContent = "";
        settingsMessageEl.classList.add("hidden");
      }

      function setSettingsLoading(isLoading) {
        settingsSaveButtonEl.disabled = Boolean(isLoading);
        settingsSaveButtonEl.textContent = isLoading ? "Saving..." : "Save Settings";
      }

      function showKickoffMessage(message, type = "success") {
        kickoffMessageEl.textContent = message;
        kickoffMessageEl.classList.remove(
          "hidden",
          "border-zinc-700",
          "border-zinc-500",
          "text-zinc-200",
          "text-white",
        );

        kickoffMessageEl.classList.add("bg-zinc-900");
        if (type === "error") {
          kickoffMessageEl.classList.add("border-zinc-700", "text-zinc-200");
          return;
        }
        kickoffMessageEl.classList.add("border-zinc-500", "text-white");
      }

      function clearKickoffMessage() {
        kickoffMessageEl.textContent = "";
        kickoffMessageEl.classList.add("hidden");
      }

      function setKickoffLoading(isLoading) {
        const nextLoading = Boolean(isLoading);
        kickoffSubmitButtonEl.disabled = nextLoading;
        kickoffGoalEl.disabled = nextLoading;
        kickoffStartLoopButtonEl.disabled = nextLoading;
        kickoffStartRunnerLoopButtonEl.disabled = nextLoading;
        kickoffButtonSpinnerEl.classList.toggle("hidden", !nextLoading);
        kickoffButtonLabelEl.textContent = nextLoading ? "Saving..." : "Save Goal (Step 1)";
      }

      function setKickoffLoopLoading(isLoading) {
        setLoopStartLoading({
          isLoading,
          spinnerEl: kickoffStartLoopSpinnerEl,
          labelEl: kickoffStartLoopLabelEl,
          idleLabel: "Start Kickoff Loop (Step 2)",
        });
      }

      function setRunnerLoopLoading(isLoading) {
        setLoopStartLoading({
          isLoading,
          spinnerEl: kickoffStartRunnerLoopSpinnerEl,
          labelEl: kickoffStartRunnerLoopLabelEl,
          idleLabel: "Start Runner Loop (No Kickoff)",
        });
      }

      function setLoopStartLoading({ isLoading, spinnerEl, labelEl, idleLabel }) {
        const nextLoading = Boolean(isLoading);
        kickoffStartLoopButtonEl.disabled = nextLoading;
        kickoffStartRunnerLoopButtonEl.disabled = nextLoading;
        kickoffSprintEl.disabled = nextLoading;
        spinnerEl.classList.toggle("hidden", !nextLoading);
        labelEl.textContent = nextLoading ? "Starting..." : idleLabel;
      }

      async function submitKickoff(event) {
        event.preventDefault();
        clearKickoffMessage();

        const goal = kickoffGoalEl.value;
        if (goal.trim().length === 0) {
          showKickoffMessage("Goal is required.", "error");
          kickoffGoalEl.focus();
          return;
        }

        setKickoffLoading(true);

        try {
          const response = await fetch("/internal/kickoff", {
            method: "POST",
            headers: {
              "content-type": "application/json",
            },
            body: JSON.stringify({ goal }),
          });

          const rawResponseBody = await response.text();
          let payload = {};
          if (rawResponseBody.trim().length > 0) {
            try {
              payload = asObject(JSON.parse(rawResponseBody));
            } catch {
              payload = {};
            }
          }

          if (!response.ok) {
            const fallbackMessage =
              (typeof payload.error === "string" && payload.error.trim().length > 0
                ? payload.error.trim()
                : rawResponseBody.trim()) || `HTTP ${response.status}`;
            throw new Error(fallbackMessage);
          }

          const successMessage =
            typeof payload.message === "string" && payload.message.trim().length > 0
              ? payload.message.trim()
              : "Goal received.";
          showKickoffMessage(`${successMessage} Next: click Start Kickoff Loop (Step 2).`);
        } catch (error) {
          showKickoffMessage(`Failed to write goal: ${error?.message ?? "Unknown error"}`, "error");
        } finally {
          setKickoffLoading(false);
        }
      }

      async function startKickoffLoop() {
        clearKickoffMessage();

        const sprint = normalizeSprint(kickoffSprintEl.value);
        if (!sprint) {
          showKickoffMessage("Sprint must be one of M1, M2, M3, or M4.", "error");
          kickoffSprintEl.focus();
          return;
        }

        kickoffSprintEl.value = sprint;
        setKickoffLoopLoading(true);

        try {
          const response = await fetch("/internal/kickoff/start-loop", {
            method: "POST",
            headers: {
              "content-type": "application/json",
            },
            body: JSON.stringify({ sprint }),
          });

          const rawResponseBody = await response.text();
          let payload = {};
          if (rawResponseBody.trim().length > 0) {
            try {
              payload = asObject(JSON.parse(rawResponseBody));
            } catch {
              payload = {};
            }
          }

          if (!response.ok) {
            if (response.status === 409 && String(payload.status ?? "") === "ALREADY_RUNNING") {
              const runningSprint =
                typeof payload.sprint === "string" && payload.sprint.trim().length > 0 ? payload.sprint.trim() : sprint;
              const runningPid = Number(payload.pid);
              const runningPidText = Number.isInteger(runningPid) && runningPid > 0 ? `, PID ${runningPid}` : "";
              showKickoffMessage(`Kickoff loop is already running (Sprint ${runningSprint}${runningPidText}).`);
              return;
            }
            const fallbackMessage =
              (typeof payload.error === "string" && payload.error.trim().length > 0
                ? payload.error.trim()
                : rawResponseBody.trim()) || `HTTP ${response.status}`;
            throw new Error(fallbackMessage);
          }

          const successMessage =
            typeof payload.message === "string" && payload.message.trim().length > 0
              ? payload.message.trim()
              : "Kickoff loop started.";
          const statusParts = [];
          if (typeof payload.sprint === "string" && payload.sprint.trim().length > 0) {
            statusParts.push(`Sprint ${payload.sprint.trim()}`);
          }
          const pid = Number(payload.pid);
          if (Number.isInteger(pid) && pid > 0) {
            statusParts.push(`PID ${pid}`);
          }
          const suffix = statusParts.length > 0 ? ` (${statusParts.join(", ")})` : "";
          showKickoffMessage(`${successMessage}${suffix}`);
        } catch (error) {
          showKickoffMessage(`Failed to start kickoff loop: ${error?.message ?? "Unknown error"}`, "error");
        } finally {
          setKickoffLoopLoading(false);
        }
      }

      async function startRunnerLoop() {
        clearKickoffMessage();

        const sprint = normalizeSprint(kickoffSprintEl.value);
        if (!sprint) {
          showKickoffMessage("Sprint must be one of M1, M2, M3, or M4.", "error");
          kickoffSprintEl.focus();
          return;
        }

        kickoffSprintEl.value = sprint;
        setRunnerLoopLoading(true);

        try {
          const response = await fetch("/internal/runner/start-loop", {
            method: "POST",
            headers: {
              "content-type": "application/json",
            },
            body: JSON.stringify({ sprint }),
          });

          const rawResponseBody = await response.text();
          let payload = {};
          if (rawResponseBody.trim().length > 0) {
            try {
              payload = asObject(JSON.parse(rawResponseBody));
            } catch {
              payload = {};
            }
          }

          if (!response.ok) {
            if (response.status === 409 && String(payload.status ?? "") === "ALREADY_RUNNING") {
              const runningSprint =
                typeof payload.sprint === "string" && payload.sprint.trim().length > 0 ? payload.sprint.trim() : sprint;
              const runningPid = Number(payload.pid);
              const runningPidText = Number.isInteger(runningPid) && runningPid > 0 ? `, PID ${runningPid}` : "";
              showKickoffMessage(`Runner loop is already running (Sprint ${runningSprint}${runningPidText}).`);
              return;
            }
            const fallbackMessage =
              (typeof payload.error === "string" && payload.error.trim().length > 0
                ? payload.error.trim()
                : rawResponseBody.trim()) || `HTTP ${response.status}`;
            throw new Error(fallbackMessage);
          }

          const successMessage =
            typeof payload.message === "string" && payload.message.trim().length > 0
              ? payload.message.trim()
              : "Runner loop started.";
          const statusParts = [];
          if (typeof payload.sprint === "string" && payload.sprint.trim().length > 0) {
            statusParts.push(`Sprint ${payload.sprint.trim()}`);
          }
          const pid = Number(payload.pid);
          if (Number.isInteger(pid) && pid > 0) {
            statusParts.push(`PID ${pid}`);
          }
          const suffix = statusParts.length > 0 ? ` (${statusParts.join(", ")})` : "";
          showKickoffMessage(`${successMessage}${suffix}`);
        } catch (error) {
          showKickoffMessage(`Failed to start runner loop: ${error?.message ?? "Unknown error"}`, "error");
        } finally {
          setRunnerLoopLoading(false);
        }
      }

      function clearSettingsFieldValidation() {
        for (const field of Object.values(settingsFieldByName)) {
          field.classList.remove("border-zinc-300", "ring-1", "ring-zinc-300/60");
          field.classList.add("border-zinc-700");
        }
      }

      function markSettingsFieldInvalid(field) {
        if (!field) {
          return;
        }
        field.classList.remove("border-zinc-700");
        field.classList.add("border-zinc-300", "ring-1", "ring-zinc-300/60");
      }

      function toPositiveInteger(value) {
        const parsed = Number(value);
        if (!Number.isInteger(parsed) || parsed <= 0) {
          return null;
        }
        return parsed;
      }

      async function loadConfig() {
        clearSettingsFieldValidation();
        try {
          const response = await fetch("/internal/config", { cache: "no-store" });
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }
          const payload = asObject(await response.json());

          settingsTargetOwnerEl.value = typeof payload.targetOwner === "string" ? payload.targetOwner : "";
          settingsTargetRepoEl.value = typeof payload.targetRepo === "string" ? payload.targetRepo : "";
          settingsProjectNumberEl.value = Number.isInteger(payload.projectNumber) ? String(payload.projectNumber) : "";
          settingsMaxExecutorsEl.value = Number.isInteger(payload.maxExecutors) ? String(payload.maxExecutors) : "";
          settingsMaxReviewersEl.value = Number.isInteger(payload.maxReviewers) ? String(payload.maxReviewers) : "";
          settingsGithubTokenEl.value = "";
          settingsGithubTokenEl.placeholder = payload.hasGithubToken
            ? "Token is set (enter to overwrite)"
            : "Enter token to set";

          if (settingsTargetOwnerEl.value && settingsTargetRepoEl.value) {
            targetRepoEl.textContent = `${settingsTargetOwnerEl.value}/${settingsTargetRepoEl.value}`;
          }
        } catch (error) {
          showSettingsMessage(`Unable to load config: ${error?.message ?? "Unknown error"}`, "error");
        }
      }

      async function submitConfig(event) {
        event.preventDefault();
        clearSettingsMessage();
        clearSettingsFieldValidation();

        const targetOwner = settingsTargetOwnerEl.value.trim();
        const targetRepo = settingsTargetRepoEl.value.trim();
        const projectNumber = toPositiveInteger(settingsProjectNumberEl.value);
        const maxExecutors = toPositiveInteger(settingsMaxExecutorsEl.value);
        const maxReviewers = toPositiveInteger(settingsMaxReviewersEl.value);
        const githubToken = settingsGithubTokenEl.value.trim();

        const validationErrors = [];
        if (!targetOwner) {
          validationErrors.push({ field: "targetOwner", message: "Target Owner is required." });
        }
        if (!targetRepo) {
          validationErrors.push({ field: "targetRepo", message: "Target Repo is required." });
        }
        if (!projectNumber) {
          validationErrors.push({ field: "projectNumber", message: "Project V2 Number must be a positive integer." });
        }
        if (!maxExecutors) {
          validationErrors.push({ field: "maxExecutors", message: "Max Executors must be a positive integer." });
        }
        if (!maxReviewers) {
          validationErrors.push({ field: "maxReviewers", message: "Max Reviewers must be a positive integer." });
        }

        if (validationErrors.length > 0) {
          for (const error of validationErrors) {
            markSettingsFieldInvalid(settingsFieldByName[error.field]);
          }
          showSettingsMessage(validationErrors.map((error) => error.message).join(" "), "error");
          const firstInvalidField = settingsFieldByName[validationErrors[0].field];
          if (firstInvalidField) {
            firstInvalidField.focus();
          }
          return;
        }

        const body = {
          targetOwner,
          targetRepo,
          projectNumber,
          maxExecutors,
          maxReviewers,
        };
        if (githubToken) {
          body.githubToken = githubToken;
        }

        setSettingsLoading(true);
        try {
          const response = await fetch("/internal/config", {
            method: "POST",
            headers: {
              "content-type": "application/json",
            },
            body: JSON.stringify(body),
          });

          const rawResponseBody = await response.text();
          let payload = {};
          if (rawResponseBody.trim().length > 0) {
            try {
              payload = asObject(JSON.parse(rawResponseBody));
            } catch {
              payload = {};
            }
          }

          if (!response.ok) {
            const serverErrors = Array.isArray(payload.errors) ? payload.errors : [];
            for (const error of serverErrors) {
              if (typeof error?.field === "string") {
                markSettingsFieldInvalid(settingsFieldByName[error.field]);
              }
            }
            const serverMessages = serverErrors
              .map((error) => (typeof error?.message === "string" ? error.message : ""))
              .filter((message) => message.length > 0);
            const fallbackMessage =
              (typeof payload.error === "string" && payload.error.trim().length > 0
                ? payload.error.trim()
                : rawResponseBody.trim()) || `HTTP ${response.status}`;
            const message = serverMessages.length > 0 ? serverMessages.join(" ") : fallbackMessage;
            throw new Error(message);
          }

          settingsGithubTokenEl.value = "";
          settingsGithubTokenEl.placeholder = payload.hasGithubToken
            ? "Token is set (enter to overwrite)"
            : "Enter token to set";
          showSettingsMessage("Settings saved.");

          targetRepoEl.textContent = `${targetOwner}/${targetRepo}`;
          loadStatus();
        } catch (error) {
          showSettingsMessage(`Failed to save settings: ${error?.message ?? "Unknown error"}`, "error");
        } finally {
          setSettingsLoading(false);
        }
      }

      function resizeCanvas() {
        const dpr = Math.max(1, window.devicePixelRatio || 1);
        canvasWidth = window.innerWidth;
        canvasHeight = window.innerHeight;
        canvas.width = Math.floor(canvasWidth * dpr);
        canvas.height = Math.floor(canvasHeight * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        const targetCount = Math.min(140, Math.max(55, Math.floor((canvasWidth * canvasHeight) / 22000)));

        if (nodes.length > targetCount) {
          nodes.length = targetCount;
        }

        while (nodes.length < targetCount) {
          nodes.push({
            x: Math.random() * canvasWidth,
            y: Math.random() * canvasHeight,
            vx: (Math.random() * 2 - 1) * 0.35,
            vy: (Math.random() * 2 - 1) * 0.35,
            size: Math.random() * 1.5 + 0.6,
          });
        }
      }

      function animateBackground(now) {
        const dt = Math.min(0.05, (now - lastFrameTime) / 1000 || 0.016);
        lastFrameTime = now;

        activityCurrent += (activityTarget - activityCurrent) * 0.04;

        const speedScale = 0.18 + activityCurrent * 1.9;
        const connectionDistance = 95 + activityCurrent * 90;
        const connectionDistanceSquared = connectionDistance * connectionDistance;
        const lineBaseAlpha = 0.03 + activityCurrent * 0.24;
        const nodeAlpha = 0.2 + activityCurrent * 0.6;

        ctx.clearRect(0, 0, canvasWidth, canvasHeight);

        for (let i = 0; i < nodes.length; i += 1) {
          const node = nodes[i];

          node.x += node.vx * speedScale * (dt * 60);
          node.y += node.vy * speedScale * (dt * 60);

          if (node.x < -20) node.x = canvasWidth + 20;
          if (node.x > canvasWidth + 20) node.x = -20;
          if (node.y < -20) node.y = canvasHeight + 20;
          if (node.y > canvasHeight + 20) node.y = -20;
        }

        for (let i = 0; i < nodes.length; i += 1) {
          const a = nodes[i];
          for (let j = i + 1; j < nodes.length; j += 1) {
            const b = nodes[j];
            const dx = a.x - b.x;
            const dy = a.y - b.y;
            const distanceSquared = dx * dx + dy * dy;
            if (distanceSquared > connectionDistanceSquared) {
              continue;
            }

            const distance = Math.sqrt(distanceSquared);
            const t = 1 - distance / connectionDistance;
            ctx.strokeStyle = `rgba(255,255,255,${(lineBaseAlpha * t).toFixed(4)})`;
            ctx.lineWidth = 0.5 + t * 0.9;
            ctx.beginPath();
            ctx.moveTo(a.x, a.y);
            ctx.lineTo(b.x, b.y);
            ctx.stroke();
          }
        }

        for (const node of nodes) {
          ctx.fillStyle = `rgba(255,255,255,${(nodeAlpha * 0.7).toFixed(4)})`;
          ctx.beginPath();
          ctx.arc(node.x, node.y, node.size, 0, Math.PI * 2);
          ctx.fill();
        }

        animationFrameId = window.requestAnimationFrame(animateBackground);
      }

      async function loadStatus() {
        try {
          const response = await fetch("/internal/status", { cache: "no-store" });
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }

          const payload = asObject(await response.json());
          const orchestrator = asObject(payload?.orchestrator);
          const runner = asObject(payload?.runner);
          const runnerEntries = buildRunnerEntries(runner);

          const ownerHeader = response.headers.get("x-target-owner") ?? "";
          const repoHeader = response.headers.get("x-target-repo") ?? "";

          targetRepoEl.textContent = deriveTargetFromData(orchestrator, runner, ownerHeader, repoHeader);
          orchestratorSprintEl.textContent = deriveSprint(orchestrator);
          renderOrchestrator(orchestrator);
          renderRunner(runnerEntries);
          syncTerminalRuns(runnerEntries);
          renderTerminalHealth(runnerEntries);
          computeAnimationActivity(orchestrator, runner);
          lastRefreshEl.textContent = formatTime(new Date().toISOString());
          clearError();
        } catch (error) {
          showError(`Unable to refresh status data: ${error?.message ?? "Unknown error"}`);
          lastRefreshEl.textContent = "Refresh failed";
          activityTarget = 0.12;
        }
      }

      window.addEventListener("resize", resizeCanvas, { passive: true });
      settingsOpenButtonEl.addEventListener("click", () => {
        clearSettingsMessage();
        setSettingsOpen(true);
      });
      settingsCloseButtonEl.addEventListener("click", () => setSettingsOpen(false));
      settingsCancelButtonEl.addEventListener("click", () => setSettingsOpen(false));
      settingsBackdropEl.addEventListener("click", () => setSettingsOpen(false));
      settingsFormEl.addEventListener("submit", submitConfig);
      kickoffFormEl.addEventListener("submit", submitKickoff);
      kickoffStartLoopButtonEl.addEventListener("click", startKickoffLoop);
      kickoffStartRunnerLoopButtonEl.addEventListener("click", startRunnerLoop);
      terminalTabsEl.addEventListener("click", (event) => {
        if (!(event.target instanceof Element)) {
          return;
        }
        const button = event.target.closest("button[data-run-id]");
        if (!button) {
          return;
        }
        setActiveTerminalRun(button.getAttribute("data-run-id"));
      });
      window.addEventListener("keydown", (event) => {
        if (event.key === "Escape" && isSettingsOpen) {
          setSettingsOpen(false);
        }
      });

      resizeCanvas();
      animationFrameId = window.requestAnimationFrame(animateBackground);

      loadConfig();
      loadStatus();
      setInterval(loadStatus, POLL_INTERVAL_MS);
      restartTerminalStreamNow();
      document.addEventListener("visibilitychange", () => {
        if (document.hidden) {
          closeTerminalStream();
          clearTerminalStreamReconnectTimer();
        } else {
          restartTerminalStreamNow();
        }
      });

      window.addEventListener("beforeunload", () => {
        if (animationFrameId) {
          window.cancelAnimationFrame(animationFrameId);
        }
        closeTerminalStream();
        clearTerminalStreamReconnectTimer();
      });
    </script>
  </body>
</html>
